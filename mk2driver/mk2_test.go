/**
write out: []byte{0x04, 0xff, 0x41, 0x01, 0x00, 0xbb, }
read byte: []byte{0x04, }
read byte: []byte{0xff, }
read unlocked: []byte{0x41, 0x01, 0x00, 0xbb, }
2019/03/17 16:24:17 Locked



write out: []byte{0x04, 0xff, 0x41, 0x01, 0x00, 0xbb, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x00, 0x00, 0x6f, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x01, 0x00, 0x6e, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x02, 0x00, 0x6d, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x03, 0x00, 0x6c, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x04, 0x00, 0x6b, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x05, 0x00, 0x6a, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x06, 0x00, 0x69, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x07, 0x00, 0x68, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x08, 0x00, 0x67, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x09, 0x00, 0x66, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x0a, 0x00, 0x65, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x0b, 0x00, 0x64, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x0c, 0x00, 0x63, }
write out: []byte{0x05, 0xff, 0x57, 0x36, 0x0d, 0x00, 0x62, }
write out: []byte{0x03, 0xff, 0x46, 0x00, 0xb8, }
write out: []byte{0x03, 0xff, 0x46, 0x01, 0xb7, }
write out: []byte{0x02, 0xff, 0x4c, 0xb3, }
write out: []byte{0x05, 0xff, 0x57, 0x30, 0x0d, 0x00, 0x68, }
write out: []byte{0x03, 0xff, 0x46, 0x00, 0xb8, }
write out: []byte{0x03, 0xff, 0x46, 0x01, 0xb7, }
write out: []byte{0x02, 0xff, 0x4c, 0xb3, }
write out: []byte{0x05, 0xff, 0x57, 0x30, 0x0d, 0x00, 0x68, }
*/

package mk2driver_test

import (
	"bytes"
	"io"
	"testing"

	"github.com/diebietse/invertergui/mk2driver"
	"github.com/stretchr/testify/assert"
)

var knownWrites = []byte{
	0x04, 0xff, 0x41, 0x01, 0x00, 0xbb,
	0x05, 0xff, 0x57, 0x36, 0x00, 0x00, 0x6f,
	0x05, 0xff, 0x57, 0x36, 0x01, 0x00, 0x6e,
	0x05, 0xff, 0x57, 0x36, 0x02, 0x00, 0x6d,
	0x05, 0xff, 0x57, 0x36, 0x03, 0x00, 0x6c,
	0x05, 0xff, 0x57, 0x36, 0x04, 0x00, 0x6b,
	0x05, 0xff, 0x57, 0x36, 0x05, 0x00, 0x6a,
	0x05, 0xff, 0x57, 0x36, 0x06, 0x00, 0x69,
	0x05, 0xff, 0x57, 0x36, 0x07, 0x00, 0x68,
	0x05, 0xff, 0x57, 0x36, 0x08, 0x00, 0x67,
	0x05, 0xff, 0x57, 0x36, 0x09, 0x00, 0x66,
	0x05, 0xff, 0x57, 0x36, 0x0a, 0x00, 0x65,
	0x05, 0xff, 0x57, 0x36, 0x0b, 0x00, 0x64,
	0x05, 0xff, 0x57, 0x36, 0x0c, 0x00, 0x63,
	0x05, 0xff, 0x57, 0x36, 0x0d, 0x00, 0x62,
	0x03, 0xff, 0x46, 0x00, 0xb8,
	0x03, 0xff, 0x46, 0x01, 0xb7,
	0x02, 0xff, 0x4c, 0xb3,
	0x05, 0xff, 0x57, 0x30, 0x0d, 0x00, 0x68,
}

var writeBuffer = bytes.NewBuffer(nil)

type testIo struct {
	io.Reader
	io.Writer
}

func NewIOStub(readBuffer []byte) io.ReadWriter {
	return &testIo{
		Reader: bytes.NewBuffer(readBuffer),
		Writer: writeBuffer,
	}
}

// Test a know sequence as reference as extracted from Mk2
func TestSync(t *testing.T) {
	knownReadBuffer := []byte{
		//Len  Cmd
		0x04, 0xff, 0x41, 0x01, 0x00, 0xbb, 0x07, 0xff, 0x56, 0x96, 0x3e, 0x11, 0x00, 0x00, 0xbf,
		0x08, 0xff, 0x57, 0x8e, 0x9c, 0x7f, 0x8f, 0x00, 0x00, 0x6a,
		0x08, 0xff, 0x57, 0x8e, 0x64, 0x80, 0x8f, 0x00, 0x00, 0xa1,
		0x08, 0xff, 0x57, 0x8e, 0x9c, 0x7f, 0x8f, 0x00, 0x00, 0x6a,
		0x08, 0xff, 0x57, 0x8e, 0x9c, 0x7f, 0x8f, 0x00, 0x00, 0x6a,
		0x08, 0xff, 0x57, 0x8e, 0x9c, 0x7f, 0x8f, 0x00, 0x00, 0x6a,
		0x08, 0xff, 0x57, 0x8e, 0x64, 0x80, 0x8f, 0x00, 0x00, 0xa1,
		0x08, 0xff, 0x57, 0x8e, 0x9c, 0x7f, 0x8f, 0x00, 0x00, 0x6a,
		0x08, 0xff, 0x57, 0x8e, 0x57, 0x78, 0x8f, 0x00, 0x01, 0xb5,
		0x08, 0xff, 0x57, 0x8e, 0x2f, 0x7c, 0x8f, 0x00, 0x00, 0xda,
		0x08, 0xff, 0x57, 0x8e, 0x64, 0x80, 0x8f, 0x00, 0x00, 0xa1,
		0x08, 0xff, 0x57, 0x8e, 0x04, 0x00, 0x8f, 0x00, 0x80, 0x01,
		0x08, 0xff, 0x57, 0x8e, 0x01, 0x00, 0x8f, 0x00, 0x80, 0x04,
		0x08, 0xff, 0x57, 0x8e, 0x02, 0x00, 0x8f, 0x00, 0x80, 0x03,
		0x08, 0xff, 0x57, 0x8e, 0x38, 0x7f, 0x8f, 0x00, 0x00, 0xce,
		0x07, 0xff, 0x56, 0x96, 0x3e, 0x11, 0x00, 0x00, 0xbf,
		0x0f, 0x20, 0xf3, 0x00, 0xc8, 0x02, 0x0c, 0xa1, 0x05, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x88, 0xb2,
		0x0f, 0x20, 0x01, 0x01, 0xca, 0x09, 0x08, 0xaa, 0x58, 0xab, 0x00, 0xaa, 0x58, 0x9a, 0x00, 0xc3, 0xe8,
		0x06, 0xff, 0x4c, 0x03, 0x00, 0x00, 0x00, 0xac,
		0x05, 0xff, 0x57, 0x85, 0xc8, 0x00, 0x58,
	}

	expectedLEDs := map[mk2driver.Led]mk2driver.LEDstate{
		mk2driver.LedMain:        mk2driver.LedOn,
		mk2driver.LedAbsorption:  mk2driver.LedOn,
		mk2driver.LedBulk:        mk2driver.LedOff,
		mk2driver.LedFloat:       mk2driver.LedOff,
		mk2driver.LedInverter:    mk2driver.LedOff,
		mk2driver.LedOverload:    mk2driver.LedOff,
		mk2driver.LedLowBattery:  mk2driver.LedOff,
		mk2driver.LedTemperature: mk2driver.LedOff,
	}
	testIO := NewIOStub(knownReadBuffer)
	mk2, err := mk2driver.NewMk2Connection(testIO)
	assert.NoError(t, err, "Could not open MK2")

	event := <-mk2.C()
	mk2.Close()

	assert.Equal(t, 0, bytes.Compare(writeBuffer.Bytes(), knownWrites), "Expected writes did not match received writes")
	assert.True(t, event.Valid, "data not valid")
	assert.Equal(t, uint32(2736), event.Version, "Invalid version decoded")
	assert.Equal(t, 0, len(event.Errors), "Reported errors not empty")
	assert.Equal(t, expectedLEDs, event.LEDs, "Reported LEDs incorrect")

	epsilon := 0.00000001
	assert.InEpsilon(t, 14.41, event.BatVoltage, epsilon, "BatVoltage conversion failed")
	assert.InEpsilon(t, -0.4, event.BatCurrent, epsilon, "BatCurrent conversion failed")
	assert.InEpsilon(t, 226.98, event.InVoltage, epsilon, "InVoltage conversion failed")
	assert.InEpsilon(t, 1.71, event.InCurrent, epsilon, "InCurrent conversion failed")
	assert.InEpsilon(t, 50.10256410256411, event.InFrequency, epsilon, "InFrequency conversion failed")
	assert.InEpsilon(t, 226.980, event.OutVoltage, epsilon, "OutVoltage conversion failed")
	assert.InEpsilon(t, 1.54, event.OutCurrent, epsilon, "OutCurrent conversion failed")
	assert.InEpsilon(t, 50.025510204081634, event.OutFrequency, epsilon, "OutFrequency conversion failed")
	assert.InEpsilon(t, 1, event.ChargeState, epsilon, "ChargeState conversion failed")
}
